---
title: Node.js - Connect to MongoDB
---

---

## Before start

To connect to MongoDB, you need something called a **connection string**.

There are **two ways** to obtain this:

1. **Using MongoDB Atlas** (Cloud)
2. **Installing MongoDB manually**

---

### Using MongoDB Atlas

This is the easiest method. Simply:

- Go to [MongoDB Atlas](https://www.mongodb.com/atlas)
- Create a **cluster**
- Retrieve the **connection string**

---

### Installing MongoDB Locally (Using Docker)

For a more hands-on approach, you can install MongoDB yourself.

I prefer using **Docker** to:

- Pull the MongoDB image
- Create a MongoDB container

⚠️ _I will cover the detailed installation process in a separate article._  
For now, let’s assume you already have a **connection string** and move on.

---

## 1. Disadvantages of the Old Connection Method

### Old Method (Basic Connection Example)

```javascript
"use strict";

const mongoose = require("mongoose");

const connectString = "mongodb://admin:adminpass@localhost:27017/";
console.log(connectString);

mongoose
  .connect(connectString)
  .then(() => console.log(`Connected to MongoDB successfully`))
  .catch((error) => console.error(`Connection Failed: ${error}`));

module.exports = mongoose;
```

---

### Important Insights on Database Connections

#### **PHP & Java (New Connection on Each Request)**

- In **PHP and Java**, each API request (e.g., `/api/user/list`) triggers the script to **restart from scratch**.
- This results in a **new database connection on every request**, unless:
  - **Persistent connections** are used (PHP).
  - **Connection pooling** is used (Java).

---

#### **Node.js (Reuses Cached Connection)**

- In **Node.js**, the server **stays running** between API calls.
- The `require` system **caches the database connection**, meaning:
  - The **first time** `require("./db")` runs, it **connects to MongoDB**.
  - On every subsequent API request (`/api/user/list`), it **reuses the same connection** instead of creating a new one.

---

#### **Comparison Table**

| **Feature**          | **PHP & Java** ❌                                    | **Node.js** ✅                                   |
| -------------------- | ---------------------------------------------------- | ------------------------------------------------ |
| API request behavior | **Script re-runs** on every request                  | **Server stays running**                         |
| Connection handling  | **New DB connection per request** (unless optimized) | **Reuses same connection** (cached by `require`) |
| Performance Impact   | Can cause **duplicate DB connections**               | **Efficient & optimized**                        |

---

### Why the Old Connection Method is Bad

#### **Issue #1: Connecting to Multiple Databases**

If you need to connect to **multiple databases**, you have two bad options:

1. **Using `.then()` to chain connections**

   - **Bad practice**: MongoDB **replaces** the previous connection each time. Only the **last one** remains active!

2. **Using `mongoose.createConnection()` for each database**
   - **Code duplication**: If you connect to **three databases**, you repeat the same logic **three times**.

#### **Conclusion**

The **old connection method is inefficient** and **not recommended**. In future posts, I’ll cover **better alternatives** for handling multiple database connections.

## 2. Moving to the New Connection Method - using Singleton Pattern
```javascript
"use strict";
const mongoose = require("mongoose");
const connectString = "mongodb://admin:adminpass@localhost:27017/";

class Database {
  constructor() {
    this.connect();
  }

  connect() {
     const connectString = process.env.MONGO_URI || "mongodb://admin:adminpass@localhost:27017/";

    // Enable debugging only in development
    if (process.env.NODE_ENV === "development") {
      mongoose.set("debug", true);
      mongoose.set("debug", { color: true });
    }

    mongoose
      .connect(connectString)
      .then((_) => console.log("Connect to DB successfully"))
      .catch((err) => console.log(`ERROR: ${err}`));
  }

  static getInstance() {
    if (!Database.instance) {
      Database.instance = new Database();
    }

    return Database.instance;
  }
}
const instanceMongodb = Database.getInstance();

module.exports = instanceMongodb;
```
## 3. Beside
### 3.1 Count number of connections
```javascript
"use strict";

const mongoose = require("mongoose");
const countConnect = () => {
  const count = mongoose.connections.length;
  console.log(`Number of connections:::`, count);
};

module.exports = {
  countConnect,
};

```
---
### 3.2 Check overload
```javascript
const os = require("os");
const process = require("process");
const { convertByteToMB } = require("../utils/convert-unit.utils");
const _SECONDS = 5000;
const _MAX_CONNECTION_EACH_CORE = 5;
const checkOverload = () => {
  setInterval(() => {
    const numConnection = mongoose.connections.length;
    const numCores = os.cpus().length;
    const memoryUsage = process.memoryUsage().rss;

    console.log(`Active connections:::`, numConnection);
    console.log(`Memory usaged:::`, convertByteToMB(memoryUsage));

    // Assumed that each core can maximun processed 5 connections.
    if (numCores * _MAX_CONNECTION_EACH_CORE < numConnection) {
      console.log(`Connection overload detected!`);
    }
  }, _SECONDS);
};
```
